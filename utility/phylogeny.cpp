/*
 * phylogeny.cpp
 *
 *  Created on: 20 Jul 2016
 *      Author: mac
 */

#include <cstring>
#include <set>
#include <stdio.h>
#include "debugging.h"
#include "../src/project.h"
#include "../src/subflat.h"
#include "phylogeny.h"

//extern bool _debugging;

using namespace std;

namespace flatbush {

const int kMediumStringLength = 65536;
char treebuf[kMediumStringLength];	// XXX magic number

Phylogeny::Phylogeny() : root(nullptr), labelSpace(0), numLeaves(0) {
}

Phylogeny::~Phylogeny() {
}

void Phylogeny::addAllDescendants(std::vector<leafset>& splits, Node* v) {
	// Perform a bottom-up (depth first) traversal from this node. Each child of v has its own subtrees.
	leafset allDescendants;
	if (v->isLeaf()) {
		allDescendants[v->getIndex()] = true;
	}
}

void Phylogeny::calculateHeights(Node* v) {
	/**
	 * The height of a vertex is 0 for leaves and max of height+1 of each of its children for internal vertices.
	 */
	root->calculateHeight();
}

void Phylogeny::calculateLeaves() {
	calculateLeaves(root);
	// calculate the indices of the leaves:
	map<int, string> id;	// 0 -> first taxon, 1 -> next taxon, etc.
	int idx = 0;
	orderedLeaves.insert(leaves.begin(), leaves.end());
	for (auto x : leaves) {
		cout << "\t" << x->getLabel() << endl;
	}
	for (auto s : orderedLeaves) {
		id[idx] = s->getLabel();
		s->setIndex(idx);
		++idx;
	}
	numLeaves = idx;
	root->clearTraversal();
	root->getAllDescendants(splits, numLeaves);
	removeRedundantSplits();
}

void Phylogeny::calculateLeaves(Node* v) {
	if (v->isLeaf()) {
		leaves.push_back(v);
	} else {
		Node* child = v->getFirstChild();
		while (child != nullptr) {
			calculateLeaves(child);
			child = child->getSibling();
		}
	}
}

/**
 * Traverse the tree from the root node and print it in ASCII characters to the ostream
 */
void Phylogeny::compressTraverseWrite(ostream& os) {
	if (leaves.empty()) {
		calculateLeaves(root);
		calculateHeights(root);
	}
	labelSpace = getMaxLabelWidth(root);
	compressTraverseWrite(os, root);
}
void Phylogeny::compressTraverseWrite(ostream & os, Node* p) {
	int
		spacing;
	char
		hline = '-',
		link[256],
		vline = '|';
	if (p != nullptr) {
		Node* q = p->getParent();
		int startpos = 0, stoppos = 0;
		spacing = 2 + labelSpace;
/* q is the parent. Height of a vertex is the distance from the root as it is scaled
 * from the time of the vertex, with time(root) = 1 and time(tips) = 1 typically.
 * Thus we have startpos = q->height and stoppos = p->height.  Let's give that a try...
 */
		if (p != root) {
			startpos = spacing*(root->getHeight()+1 - q->getHeight());
			stoppos = spacing*(root->getHeight()+1 - p->getHeight());
		}
		int i;	// handy counter
		for (i = startpos + 1; i <= stoppos; ++i)
			treebuf[i] = hline;
		strncpy(link, "--------------------------------", spacing);
		if (p->getParent() != nullptr) {
			if (p->getParent()->getFirstChild() == p) {	// p is the first child
				memcpy(link, q->getLabel().c_str(), q->getLabel().length());
			}
		} else {				// p is the last sibling
			if (p->getSibling() != nullptr)
				strncpy(link, "                                ", spacing);
			else
				link[0] = '+';
			while (q != nullptr) {
				if (q->getSibling() != nullptr) {
					i = spacing*(root->getHeight()+1 - q->getParent()->getHeight());
//					i = spacing*(1 + q->vpar()->height);
					treebuf[i++] = vline;
					for ( ; i < spacing; i++)
						treebuf[i] = ' ';
				}
				q = q->getParent();
			}
		}
		char *ptr = treebuf + (startpos * sizeof(char));
		strncpy(ptr, link, spacing);
		// if p is a leaf then we need to output the line buffer:
		if (p->getFirstChild() == nullptr) {
			treebuf[spacing*(root->getHeight()+1)] = '\0';
			os << treebuf << " " << p->getLabel() << "\n";
			os.flush();
			// we've output the string now, so clear the buffer:
			for (i = 0; i < kMediumStringLength; i++)
				treebuf[i] = ' ';
		} else {
			compressTraverseWrite(os, p->getFirstChild());
		}
		if (p->getSibling() != nullptr)
			compressTraverseWrite(os, p->getSibling());
	}
}

int Phylogeny::getMaxLabelWidth(Node *v) {
	int length = v->getLabel().length();
	Node* child = v->getFirstChild();
	while (child != nullptr) {
		length= max(length, getMaxLabelWidth(child));
		child = child->getSibling();
	}
	return length;
}

void Phylogeny::removeRedundantSplits() {
	/**
	 *  the splits are generated by a depth-first traversal of a rooted tree;
	 *  therefore there will be some splits that are duplicated as they're mirrors of each other,
	 *  e.g.,
	 *  	tree T = (((A, B), C), D);
	 *  gives splits { A }, { B }, { A, B }, { C }, { A, B, C }, { D }, and { A, B, C, D }.
	 *  This function removes the singletons (we don't care about them) and "null" split (with everything),
	 *  and all splits that do not contain the 0th taxon.
	 *  In the above toy example this would be (with A=0, B=1, C=2, D=3), just { A, B }.
	 */
	bool _debugging = false;
	DEBUG(cout << "BEFORE:" << endl;
	for (leafset l : splits) {
		cout << strmLeafset(l) << endl;
	});

	set<leafset> nonredundants;
	for (leafset l : splits) {
		DEBUG(cout << "checking " << strmLeafset(l) << endl);
		if (card(l) <= 1 || card(l) == numLeaves) {
			DEBUG(cout << "\twrong size" << endl);
			continue;
		}
		if (l.at(0)) {
			nonredundants.insert(l);
			DEBUG(cout << "\tall good" << endl);
		} else {
			leafset r(numLeaves, false);
			for (unsigned int i = 0; i < numLeaves; ++i) {
				r[i] = (l[i] == true) ? false : true;
			}
			nonredundants.insert(r);
			DEBUG(cout << "\t retaining inverse " << strmLeafset(r) << endl);
		}
	}
	splits.clear();
	splits.insert(nonredundants.begin(), nonredundants.end());
	DEBUG(cout << "AFTER: " << endl;
	for (leafset l : splits) {
		cout << strmLeafset(l) << endl;
	});
}

} /* namespace parsing */
